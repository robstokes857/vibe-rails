<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeRails Trace</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.8/slate/bootstrap.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
    <style>
        html, body {
            height: 100vh;
            overflow: hidden;
            font-family: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
        }

        /* ── Top bar ── */
        .topbar {
            background: #1a1a2e;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }
        .topbar-title { font-size: 13px; font-weight: 700; color: #569cd6; letter-spacing: 0.12em; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .status-dot.connected    { background: #4caf50; box-shadow: 0 0 6px #4caf50; }
        .status-dot.disconnected { background: #d73a49; }
        .status-dot.connecting   { background: #e3b341; }
        .status-label { font-size: 11px; color: #888; }

        /* ── Main grid fills remaining height ── */
        .main-grid {
            flex: 1;
            min-height: 0;
        }
        .main-grid > .row {
            height: 100%;
        }

        /* ── Left column: support panels ── */
        .left-col {
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: 100%;
            padding: 8px;
            min-height: 0;
        }
        .left-col .panel { flex: 1; min-height: 0; }
        .left-col .panel.minimized { flex: 0 0 auto; }

        /* ── Right column: one box with TERMINAL event stack ── */
        .right-col {
            height: 100%;
            padding: 8px 8px 8px 0;
            min-height: 0;
        }
        .io-stack-shell {
            height: 100%;
            min-height: 0;
            display: flex;
            flex-direction: column;
            border-radius: 6px;
            overflow: hidden;
            background: #131324;
            border: 1px solid #2a2a3e;
        }
        .io-stack-body {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 6px;
        }
        .pane-section {
            min-height: 90px;
            display: flex;
            flex-direction: column;
        }
        .pane-section > .panel {
            flex: 1;
            min-height: 0;
        }
        .pane-resizer {
            height: 8px;
            margin: 2px 0;
            cursor: row-resize;
            position: relative;
            flex: 0 0 auto;
        }
        .pane-resizer::before {
            content: '';
            position: absolute;
            left: 20%;
            right: 20%;
            top: 3px;
            height: 2px;
            border-radius: 2px;
            background: #2e2e3e;
        }
        .pane-resizer:hover::before {
            background: #569cd6;
        }
        .collapsed-dock {
            flex: 0 0 auto;
            border-top: 1px solid #2b2b40;
            background: #10101d;
            min-height: 30px;
            padding: 5px 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        .collapsed-dock-label {
            font-size: 10px;
            color: #666;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        .collapsed-pane-btn {
            font-size: 10px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 3px;
            background: transparent;
            color: #8a8a9b;
            cursor: pointer;
            font-family: inherit;
        }
        .collapsed-pane-btn:hover {
            color: #d4d4d4;
            border-color: #569cd6;
        }
        .collapsed-dock.hidden {
            display: none;
        }

        /* ── Panel card ── */
        .panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
            border-radius: 6px;
            overflow: hidden;
            background: #1a1a2e;
            border: 1px solid #2a2a3e;
        }

        /* Accent borders */
        .panel-launch   { border-color: #3f3310; }
        .panel-input    { border-color: #1e3a5f; }
        .panel-mcp      { border-color: #4a2800; }
        .panel-logs     { border-color: #2d1a45; }
        .panel-output   { border-color: #1a4038; }
        .panel-console  { border-color: #2a2a3e; }
        .panel-http     { border-color: #2d3a1a; }
        .panel-proc     { border-color: #1a3040; }

        /* ── Minimized panel (left support column only) ── */
        .left-col .panel.minimized { flex: 0 0 auto !important; min-height: 0 !important; }
        .left-col .panel.minimized .panel-body,
        .left-col .panel.minimized .terminal-wrap { display: none !important; }

        /* ── Panel header ── */
        .panel-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: #16162a;
            border-bottom: 1px solid;
            flex-shrink: 0;
        }
        .panel-launch  .panel-header { border-color: #3f3310; }
        .panel-input   .panel-header { border-color: #1e3a5f; }
        .panel-mcp     .panel-header { border-color: #4a2800; }
        .panel-logs    .panel-header { border-color: #2d1a45; }
        .panel-output  .panel-header { border-color: #1a4038; }
        .panel-console .panel-header { border-color: #333; }
        .panel-http    .panel-header { border-color: #2d3a1a; }
        .panel-proc    .panel-header { border-color: #1a3040; }

        .panel-label { font-size: 10px; font-weight: 700; letter-spacing: 0.12em; text-transform: uppercase; }
        .panel-launch  .panel-label { color: #d7ba7d; }
        .panel-input   .panel-label { color: #569cd6; }
        .panel-mcp     .panel-label { color: #ce9178; }
        .panel-logs    .panel-label { color: #c586c0; }
        .panel-output  .panel-label { color: #4ec9b0; }
        .panel-console .panel-label { color: #888; }
        .panel-http    .panel-label { color: #8fbc45; }
        .panel-proc    .panel-label { color: #56a8d6; }

        .panel-count { font-size: 10px; color: #555; }

        .panel-btn {
            font-size: 10px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 3px;
            background: transparent;
            color: #666;
            cursor: pointer;
            font-family: inherit;
        }
        .panel-btn:hover { color: #d4d4d4; border-color: #569cd6; }
        .panel-btn.locked { color: #d4d4d4; opacity: 1; }

        /* ── Panel body ── */
        .panel-body {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        .panel-body::-webkit-scrollbar { width: 6px; }
        .panel-body::-webkit-scrollbar-track { background: transparent; }
        .panel-body::-webkit-scrollbar-thumb { background: #2e2e3e; border-radius: 3px; }
        .panel-body::-webkit-scrollbar-thumb:hover { background: #444; }

        /* ── Terminal/console container ── */
        .terminal-wrap {
            flex: 1;
            min-height: 0;
            padding: 4px;
            overflow: hidden;
        }
        .terminal-wrap .xterm { height: 100%; }
        .terminal-wrap .xterm-viewport { border-radius: 3px; }
        #terminal-status {
            font-size: 10px;
            color: #666;
            padding: 2px 4px;
        }

        /* ── Event rows — always fully visible, no collapsing ── */
        .event-row {
            padding: 4px 12px;
            font-size: 11px;
            line-height: 1.6;
            border-bottom: 1px solid #1e1e2e;
        }
        .event-row:hover { background: #20203a; }

        .ev-meta {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }
        .ev-time { color: #444; font-size: 10px; flex-shrink: 0; white-space: nowrap; }
        .ev-duration { font-size: 10px; color: #555; flex-shrink: 0; margin-left: auto; }

        /* Full text — wraps, nothing hidden */
        .ev-text {
            font-size: 11px;
            line-height: 1.5;
            word-break: break-word;
            white-space: pre-wrap;
            padding: 1px 0;
        }
        .panel-launch .ev-text { color: #d7ba7d; }
        .panel-input  .ev-text { color: #7ab8e8; }
        .panel-output .ev-text { color: #6ab9a0; }
        .panel-mcp    .ev-text { color: #c99060; }
        .panel-logs   .ev-text { color: #c0c0c0; }
        .panel-http   .ev-text { color: #8fbc45; }

        .ev-call   .ev-text { color: #ce9178; }
        .ev-result .ev-text { color: #c8c060; }
        .ev-err    .ev-text { color: #f48771 !important; }
        .ev-wrn    .ev-text { color: #d4a020 !important; }
        .ev-dbg    .ev-text { color: #555 !important; }

        /* ── Detail block — always shown inline, never collapsed ── */
        .event-detail {
            margin: 2px 0 6px 0;
            padding: 6px 10px;
            background: #111122;
            border-left: 2px solid #333;
            font-size: 10.5px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
            color: #888;
            max-height: 400px;
            overflow-y: auto;
        }

        /* ── Empty state ── */
        .panel-empty { padding: 30px; text-align: center; color: #333; font-size: 11px; }

        /* Override Bootstrap form-control for our search */
        .global-search {
            font-family: inherit;
            font-size: 11px;
            max-width: 200px;
            background: #141428 !important;
            border-color: #333 !important;
            color: #d4d4d4 !important;
        }
        .global-search:focus {
            border-color: #569cd6 !important;
            box-shadow: 0 0 0 0.15rem rgba(86, 156, 214, 0.25) !important;
        }

        /* ── Settings popover ── */
        .settings-popover {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            z-index: 1000;
            background: #1a1a2e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px 14px 12px;
            min-width: 220px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .settings-popover.hidden { display: none; }
        .settings-group-label {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #555;
            margin: 8px 0 4px;
        }
        .settings-group-label:first-child { margin-top: 0; }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 2px 0;
        }
        .settings-row label {
            font-size: 11px;
            color: #aaa;
            cursor: pointer;
            flex: 1;
            user-select: none;
        }
        .settings-row input[type=checkbox] {
            accent-color: #569cd6;
            width: 13px;
            height: 13px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .settings-row label:hover { color: #d4d4d4; }
        .settings-divider {
            border: none;
            border-top: 1px solid #2a2a3e;
            margin: 8px 0;
        }
        .settings-btn-row {
            display: flex;
            gap: 6px;
            margin-top: 10px;
        }
        .settings-mini-btn {
            font-size: 10px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 3px;
            background: transparent;
            color: #666;
            cursor: pointer;
            font-family: inherit;
        }
        .settings-mini-btn:hover { color: #d4d4d4; border-color: #569cd6; }
        .topbar-settings-wrap { position: relative; }

        /* ── Panel visibility — hide entire panel card ── */
        .panel-hidden { display: none !important; }

        /* ── Process table ── */
        .proc-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .proc-table th {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #555;
            padding: 4px 10px;
            text-align: left;
            border-bottom: 1px solid #1e1e2e;
            position: sticky;
            top: 0;
            background: #1a1a2e;
        }
        .proc-table td {
            padding: 3px 10px;
            color: #aaa;
            border-bottom: 1px solid #1a1a2a;
            white-space: nowrap;
        }
        .proc-table tr:hover td { background: #20203a; }
        .proc-table .col-pid    { color: #569cd6; font-size: 10px; width: 60px; }
        .proc-table .col-uptime { color: #888; font-size: 10px; width: 70px; }
        .proc-table .col-title  { color: #666; font-size: 10px; }
        .proc-age { font-size: 10px; color: #444; margin-left: auto; }

        /* ── Connect bar ── */
        .connect-bar {
            background: #111120;
            border-bottom: 1px solid #2a2a3e;
            padding: 5px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            font-size: 11px;
        }
        .connect-bar.hidden { display: none; }
        .connect-bar-label { color: #555; font-size: 10px; letter-spacing: 0.08em; text-transform: uppercase; white-space: nowrap; }
        .connect-input {
            font-family: inherit;
            font-size: 11px;
            background: #141428;
            border: 1px solid #333;
            border-radius: 3px;
            color: #d4d4d4;
            padding: 2px 8px;
            outline: none;
        }
        .connect-input:focus { border-color: #569cd6; }
        .connect-input.port-input { width: 70px; }
        .connect-input.code-input { flex: 1; max-width: 340px; font-family: monospace; }
        .connect-btn {
            font-size: 10px;
            padding: 2px 10px;
            border: 1px solid #569cd6;
            border-radius: 3px;
            background: transparent;
            color: #569cd6;
            cursor: pointer;
            font-family: inherit;
            white-space: nowrap;
        }
        .connect-btn:hover { background: #569cd6; color: #fff; }
        .connect-hint { font-size: 10px; color: #444; margin-left: 4px; }
        .connect-error { font-size: 10px; color: #f48771; margin-left: 4px; }
    </style>
</head>
<body class="d-flex flex-column">

<!-- ── Top bar ── -->
<div class="topbar d-flex align-items-center gap-2 px-3 py-1">
    <span class="topbar-title">TRACE</span>
    <span class="status-dot connecting" id="status-dot"></span>
    <span class="status-label" id="status-label">Connecting...</span>
    <span class="flex-grow-1"></span>
    <input class="form-control form-control-sm global-search" id="global-search" type="text" placeholder="Filter...">
    <button class="btn btn-sm btn-outline-secondary" id="connect-toggle-btn" title="Connect to a different instance">&#x2B67; Connect</button>
    <button class="btn btn-sm btn-outline-secondary" id="pause-btn">Pause</button>
    <button class="btn btn-sm btn-outline-secondary" id="clear-all-btn">Clear All</button>
    <div class="topbar-settings-wrap">
        <button class="btn btn-sm btn-outline-secondary" id="settings-btn" title="Trace filters">&#9881; Filters</button>
        <div class="settings-popover hidden" id="settings-popover">
            <div class="settings-group-label">Terminal</div>
            <div class="settings-row"><input type="checkbox" id="filter-TerminalLaunch" checked><label for="filter-TerminalLaunch">Launch</label></div>
            <div class="settings-row"><input type="checkbox" id="filter-TerminalInput" checked><label for="filter-TerminalInput">Input</label></div>
            <div class="settings-row"><input type="checkbox" id="filter-TerminalOutput" checked><label for="filter-TerminalOutput">Output</label></div>
            <hr class="settings-divider">
            <div class="settings-group-label">MCP</div>
            <div class="settings-row"><input type="checkbox" id="filter-McpToolCall" checked><label for="filter-McpToolCall">Tool Call</label></div>
            <div class="settings-row"><input type="checkbox" id="filter-McpToolResult" checked><label for="filter-McpToolResult">Tool Result</label></div>
            <hr class="settings-divider">
            <div class="settings-group-label">HTTP</div>
            <div class="settings-row"><input type="checkbox" id="filter-HttpRequest" checked><label for="filter-HttpRequest">HTTP Request</label></div>
            <hr class="settings-divider">
            <div class="settings-group-label">Logs</div>
            <div class="settings-row"><input type="checkbox" id="filter-LogEntry" checked><label for="filter-LogEntry">Log Entry</label></div>
            <div class="settings-row"><input type="checkbox" id="filter-RuleValidation" checked><label for="filter-RuleValidation">Rule Validation</label></div>
            <div class="settings-row"><input type="checkbox" id="filter-SessionLifecycle" checked><label for="filter-SessionLifecycle">Session Lifecycle</label></div>
            <div class="settings-row"><input type="checkbox" id="filter-Idle" checked><label for="filter-Idle">Idle</label></div>
            <div class="settings-row"><input type="checkbox" id="filter-Resize" checked><label for="filter-Resize">Resize</label></div>
            <div class="settings-btn-row">
                <button class="settings-mini-btn" id="filter-all-btn">All</button>
                <button class="settings-mini-btn" id="filter-none-btn">None</button>
            </div>
            <hr class="settings-divider">
            <div class="settings-group-label">Panels</div>
            <div class="settings-row"><input type="checkbox" id="panel-show-mcp" checked><label for="panel-show-mcp">MCP</label></div>
            <div class="settings-row"><input type="checkbox" id="panel-show-http" checked><label for="panel-show-http">HTTP</label></div>
            <div class="settings-row"><input type="checkbox" id="panel-show-logs" checked><label for="panel-show-logs">Logs</label></div>
            <div class="settings-row"><input type="checkbox" id="panel-show-proc" checked><label for="panel-show-proc">Processes</label></div>
            <div class="settings-row"><input type="checkbox" id="panel-show-launch" checked><label for="panel-show-launch">Launch</label></div>
            <div class="settings-row"><input type="checkbox" id="panel-show-input" checked><label for="panel-show-input">Input</label></div>
            <div class="settings-row"><input type="checkbox" id="panel-show-output" checked><label for="panel-show-output">Output</label></div>
            <div class="settings-row"><input type="checkbox" id="panel-show-console" checked><label for="panel-show-console">Console</label></div>
        </div>
    </div>
</div>

<!-- ── Connect bar ── -->
<div class="connect-bar hidden" id="connect-bar">
    <span class="connect-bar-label">Instance</span>
    <input class="connect-input port-input" id="connect-port" type="number" placeholder="Port" min="1" max="65535">
    <span class="connect-bar-label">Bootstrap code</span>
    <input class="connect-input code-input" id="connect-code" type="text" placeholder="Paste bootstrap code or full URL">
    <button class="connect-btn" id="connect-go-btn">Connect</button>
    <span class="connect-hint" id="connect-hint">Paste the bootstrap URL from the instance's console, or enter port + code separately.</span>
</div>

<!-- ── Main grid ── -->
<div class="main-grid container-fluid p-0">
    <div class="row g-0">

        <!-- Left column: MCP, HTTP, LOGS -->
        <div class="col-6 left-col">

            <div class="panel panel-mcp" id="panel-mcp">
                <div class="panel-header">
                    <span class="panel-label">MCP</span>
                    <span class="panel-count" id="count-mcp">0</span>
                    <span class="flex-grow-1"></span>
                    <button class="panel-btn locked" id="scroll-mcp">&#x2B07;</button>
                    <button class="panel-btn" data-minimize="mcp">&#x2212;</button>
                    <button class="panel-btn" data-panel="mcp">&times;</button>
                </div>
                <div class="panel-body" id="body-mcp">
                    <div class="panel-empty">Waiting for MCP calls...</div>
                </div>
            </div>

            <div class="panel panel-http" id="panel-http">
                <div class="panel-header">
                    <span class="panel-label">HTTP</span>
                    <span class="panel-count" id="count-http">0</span>
                    <span class="flex-grow-1"></span>
                    <button class="panel-btn locked" id="scroll-http">&#x2B07;</button>
                    <button class="panel-btn" data-minimize="http">&#x2212;</button>
                    <button class="panel-btn" data-panel="http">&times;</button>
                </div>
                <div class="panel-body" id="body-http">
                    <div class="panel-empty">Waiting for requests...</div>
                </div>
            </div>

            <div class="panel panel-logs" id="panel-logs">
                <div class="panel-header">
                    <span class="panel-label">LOGS</span>
                    <span class="panel-count" id="count-logs">0</span>
                    <span class="flex-grow-1"></span>
                    <button class="panel-btn locked" id="scroll-logs">&#x2B07;</button>
                    <button class="panel-btn" data-minimize="logs">&#x2212;</button>
                    <button class="panel-btn" data-panel="logs">&times;</button>
                </div>
                <div class="panel-body" id="body-logs">
                    <div class="panel-empty">Waiting for log entries...</div>
                </div>
            </div>

            <div class="panel panel-proc" id="panel-proc">
                <div class="panel-header">
                    <span class="panel-label">PROCESSES</span>
                    <span class="panel-count" id="count-proc">0</span>
                    <span class="flex-grow-1"></span>
                    <span class="proc-age" id="proc-age"></span>
                    <button class="panel-btn" data-minimize="proc">&#x2212;</button>
                </div>
                <div class="panel-body" id="body-proc">
                    <div class="panel-empty">Polling for vb processes...</div>
                </div>
            </div>

        </div><!-- /left-col -->

        <!-- Right column: TERMINAL launch/input/output/console in one 50% box -->
        <div class="col-6 right-col">
            <div class="io-stack-shell">
                <div class="io-stack-body" id="io-stack-body">
                    <div class="pane-section" id="section-launch">
                        <div class="panel panel-launch" id="panel-launch">
                            <div class="panel-header">
                                <span class="panel-label">LAUNCH</span>
                                <span class="panel-count" id="count-launch">0</span>
                                <span class="flex-grow-1"></span>
                                <button class="panel-btn locked" id="scroll-launch">&#x2B07;</button>
                                <button class="panel-btn" data-minimize="launch">&#x2212;</button>
                                <button class="panel-btn" data-panel="launch">&times;</button>
                            </div>
                            <div class="panel-body" id="body-launch">
                                <div class="panel-empty">Waiting for terminal launch...</div>
                            </div>
                        </div>
                    </div>

                    <div class="pane-section" id="section-input">
                        <div class="panel panel-input" id="panel-input">
                            <div class="panel-header">
                                <span class="panel-label">INPUT</span>
                                <span class="panel-count" id="count-input">0</span>
                                <span class="flex-grow-1"></span>
                                <button class="panel-btn locked" id="scroll-input">&#x2B07;</button>
                                <button class="panel-btn" data-minimize="input">&#x2212;</button>
                                <button class="panel-btn" data-panel="input">&times;</button>
                            </div>
                            <div class="panel-body" id="body-input">
                                <div class="panel-empty">Waiting for input...</div>
                            </div>
                        </div>
                    </div>

                    <div class="pane-section" id="section-output">
                        <div class="panel panel-output" id="panel-output">
                            <div class="panel-header">
                                <span class="panel-label">OUTPUT</span>
                                <span class="panel-count" id="count-output">0</span>
                                <span class="flex-grow-1"></span>
                                <button class="panel-btn locked" id="scroll-output">&#x2B07;</button>
                                <button class="panel-btn" data-minimize="output">&#x2212;</button>
                                <button class="panel-btn" data-panel="output">&times;</button>
                            </div>
                            <div class="panel-body" id="body-output">
                                <div class="panel-empty">Waiting for output...</div>
                            </div>
                        </div>
                    </div>

                    <div class="pane-section" id="section-console">
                        <div class="panel panel-console" id="panel-console">
                            <div class="panel-header">
                                <span class="panel-label">CONSOLE</span>
                                <span id="terminal-status">waiting for output...</span>
                                <span class="flex-grow-1"></span>
                                <button class="panel-btn" data-minimize="console">&#x2212;</button>
                                <button class="panel-btn" id="term-reconnect-btn">Clear</button>
                            </div>
                            <div class="terminal-wrap" id="terminal-wrap"></div>
                        </div>
                    </div>
                </div>
                <div class="collapsed-dock hidden" id="collapsed-dock">
                    <span class="collapsed-dock-label">Minimized</span>
                    <div id="collapsed-pane-buttons" class="d-flex align-items-center gap-1 flex-wrap"></div>
                </div>
            </div>
        </div><!-- /right-col -->

    </div><!-- /row -->
</div><!-- /main-grid -->

<script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"></script>
<script>
// ─────────────────────────────────────────────────────────────────────────────
// Type mapping
// ─────────────────────────────────────────────────────────────────────────────
const TYPE_PANEL = {
    TerminalLaunch:   'launch',
    TerminalInput:    'input',
    TerminalOutput:   'output',
    McpToolCall:      'mcp',
    McpToolResult:    'mcp',
    RuleValidation:   'logs',
    LogEntry:         'logs',
    SessionLifecycle: 'logs',
    Idle:             'logs',
    Resize:           'logs',
    HttpRequest:      'http',
};
const TYPE_NAMES = ['TerminalInput','TerminalOutput','McpToolCall','McpToolResult',
                    'RuleValidation','LogEntry','SessionLifecycle','Idle','Resize','HttpRequest','TerminalLaunch'];

// ─────────────────────────────────────────────────────────────────────────────
// Trace type filters — persisted to localStorage
// ─────────────────────────────────────────────────────────────────────────────
const FILTER_STORAGE_KEY = 'trace-filters-v1';
const ALL_FILTER_TYPES = [
    'TerminalLaunch','TerminalInput','TerminalOutput',
    'McpToolCall','McpToolResult',
    'HttpRequest',
    'LogEntry','RuleValidation','SessionLifecycle','Idle','Resize',
];
const typeFilters = loadFilters();

function loadFilters() {
    try {
        const saved = JSON.parse(localStorage.getItem(FILTER_STORAGE_KEY) || '{}');
        const result = {};
        for (const t of ALL_FILTER_TYPES) result[t] = saved[t] !== false;
        return result;
    } catch { return Object.fromEntries(ALL_FILTER_TYPES.map(t => [t, true])); }
}

function saveFilters() {
    try { localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(typeFilters)); } catch {}
}

function isTypeEnabled(typeName) {
    return typeFilters[typeName] !== false;
}

// ─────────────────────────────────────────────────────────────────────────────
// Panel state
// ─────────────────────────────────────────────────────────────────────────────
const panels = {
    launch: { count: 0, body: null, autoScroll: true, scrollBtn: null, countEl: null },
    input:  { count: 0, body: null, autoScroll: true, scrollBtn: null, countEl: null },
    output: { count: 0, body: null, autoScroll: true, scrollBtn: null, countEl: null },
    mcp:    { count: 0, body: null, autoScroll: true, scrollBtn: null, countEl: null },
    logs:   { count: 0, body: null, autoScroll: true, scrollBtn: null, countEl: null },
    http:   { count: 0, body: null, autoScroll: true, scrollBtn: null, countEl: null },
};

let paused = false;
let pending = [];
let globalSearch = '';
const stackPanelKeys = ['launch', 'input', 'output', 'console'];
const stackBody = document.getElementById('io-stack-body');
const collapsedDock = document.getElementById('collapsed-dock');
const collapsedPaneButtons = document.getElementById('collapsed-pane-buttons');
const paneSections = {
    launch: document.getElementById('section-launch'),
    input: document.getElementById('section-input'),
    output: document.getElementById('section-output'),
    console: document.getElementById('section-console'),
};
const paneWeights = { launch: 1.1, input: 1.2, output: 1.9, console: 1.2 };
const paneMinimized = { launch: false, input: false, output: false, console: false };
const minimizeButtons = {};
let resizeDragState = null;
const groupedTerminalRows = {
    input: createGroupedRowState(),
    output: createGroupedRowState(),
};

for (const key of Object.keys(panels)) {
    panels[key].body      = document.getElementById(`body-${key}`);
    panels[key].countEl   = document.getElementById(`count-${key}`);
    panels[key].scrollBtn = document.getElementById(`scroll-${key}`);
}

// ─────────────────────────────────────────────────────────────────────────────
// Auto-scroll per panel
// ─────────────────────────────────────────────────────────────────────────────
for (const [, panel] of Object.entries(panels)) {
    panel.scrollBtn.addEventListener('click', () => {
        panel.autoScroll = !panel.autoScroll;
        panel.scrollBtn.classList.toggle('locked', panel.autoScroll);
        if (panel.autoScroll) panel.body.scrollTop = panel.body.scrollHeight;
    });
    panel.body.addEventListener('scroll', () => {
        const atBottom = panel.body.scrollHeight - panel.body.scrollTop - panel.body.clientHeight < 40;
        if (!atBottom && panel.autoScroll) {
            panel.autoScroll = false;
            panel.scrollBtn.classList.remove('locked');
        }
    });
}

// ─────────────────────────────────────────────────────────────────────────────
// TERMINAL stack layout (right side single box)
// ─────────────────────────────────────────────────────────────────────────────
function visibleStackPanels() {
    return stackPanelKeys.filter(k => !paneMinimized[k]);
}

function createPaneResizer(upperKey, lowerKey) {
    const resizer = document.createElement('div');
    resizer.className = 'pane-resizer';
    resizer.title = `Resize ${upperKey.toUpperCase()} / ${lowerKey.toUpperCase()}`;
    resizer.addEventListener('mousedown', (evt) => beginPaneResize(evt, upperKey, lowerKey));
    return resizer;
}

function renderCollapsedDock() {
    collapsedPaneButtons.innerHTML = '';
    let minimizedCount = 0;

    for (const key of stackPanelKeys) {
        const btn = minimizeButtons[key];
        if (!btn) continue;
        btn.textContent = paneMinimized[key] ? '+' : '−';

        if (!paneMinimized[key]) continue;
        minimizedCount++;

        const restoreBtn = document.createElement('button');
        restoreBtn.className = 'collapsed-pane-btn';
        restoreBtn.type = 'button';
        restoreBtn.textContent = `${key.toUpperCase()} +`;
        restoreBtn.addEventListener('click', () => setStackPaneMinimized(key, false));
        collapsedPaneButtons.appendChild(restoreBtn);
    }

    collapsedDock.classList.toggle('hidden', minimizedCount === 0);
}

function renderStackLayout() {
    if (!stackBody) return;

    const visible = visibleStackPanels();
    if (visible.length === 0) {
        setStackPaneMinimized('console', false);
        return;
    }

    stackBody.innerHTML = '';
    let totalWeight = 0;
    for (const key of visible) totalWeight += Math.max(0.35, paneWeights[key] || 1);

    visible.forEach((key, idx) => {
        const section = paneSections[key];
        if (!section) return;

        const weight = Math.max(0.35, paneWeights[key] || 1);
        section.style.display = 'flex';
        section.style.flex = `${weight / totalWeight} 1 0`;
        stackBody.appendChild(section);

        if (idx < visible.length - 1) {
            stackBody.appendChild(createPaneResizer(key, visible[idx + 1]));
        }
    });

    for (const key of stackPanelKeys) {
        if (visible.includes(key)) continue;
        const section = paneSections[key];
        if (!section) continue;
        section.style.display = 'none';
    }

    renderCollapsedDock();
    try { fitAddon.fit(); } catch {}
}

function setStackPaneMinimized(key, minimized) {
    if (!stackPanelKeys.includes(key)) return;
    if (minimized && visibleStackPanels().length <= 1) return; // keep at least one pane visible

    paneMinimized[key] = minimized;
    renderStackLayout();
}

function beginPaneResize(evt, upperKey, lowerKey) {
    evt.preventDefault();
    const upper = paneSections[upperKey];
    const lower = paneSections[lowerKey];
    if (!upper || !lower) return;

    resizeDragState = {
        startY: evt.clientY,
        upperKey,
        lowerKey,
        upperStart: upper.getBoundingClientRect().height,
        lowerStart: lower.getBoundingClientRect().height,
        minSize: 90,
    };

    document.body.style.userSelect = 'none';
    document.addEventListener('mousemove', onPaneResizeMove);
    document.addEventListener('mouseup', endPaneResize);
}

function onPaneResizeMove(evt) {
    if (!resizeDragState) return;

    const { startY, upperKey, lowerKey, upperStart, lowerStart, minSize } = resizeDragState;
    let nextUpper = upperStart + (evt.clientY - startY);
    let nextLower = lowerStart - (evt.clientY - startY);

    if (nextUpper < minSize) {
        nextLower -= (minSize - nextUpper);
        nextUpper = minSize;
    }
    if (nextLower < minSize) {
        nextUpper -= (minSize - nextLower);
        nextLower = minSize;
    }

    paneWeights[upperKey] = Math.max(minSize, nextUpper);
    paneWeights[lowerKey] = Math.max(minSize, nextLower);
    renderStackLayout();
}

function endPaneResize() {
    resizeDragState = null;
    document.body.style.userSelect = '';
    document.removeEventListener('mousemove', onPaneResizeMove);
    document.removeEventListener('mouseup', endPaneResize);
}

// ─────────────────────────────────────────────────────────────────────────────
// Controls
// ─────────────────────────────────────────────────────────────────────────────
document.getElementById('pause-btn').addEventListener('click', function() {
    paused = !paused;
    this.textContent = paused ? 'Resume' : 'Pause';
    this.classList.toggle('btn-warning', paused);
    this.classList.toggle('btn-outline-secondary', !paused);
    if (!paused && pending.length) { pending.forEach(dispatchEvt); pending = []; }
});

document.getElementById('clear-all-btn').addEventListener('click', () => {
    for (const [key, panel] of Object.entries(panels)) clearPanel(key, panel);
});

document.querySelectorAll('[data-panel]').forEach(btn => {
    btn.addEventListener('click', () => clearPanel(btn.dataset.panel, panels[btn.dataset.panel]));
});

document.querySelectorAll('[data-minimize]').forEach(btn => {
    const key = btn.dataset.minimize;
    if (stackPanelKeys.includes(key)) minimizeButtons[key] = btn;

    btn.addEventListener('click', () => {
        if (stackPanelKeys.includes(key)) {
            setStackPaneMinimized(key, !paneMinimized[key]);
            return;
        }

        const el = document.getElementById(`panel-${key}`);
        if (!el) return;
        const isMin = el.classList.toggle('minimized');
        btn.textContent = isMin ? '+' : '−';
    });
});

function clearPanel(key, panel) {
    panel.body.innerHTML = `<div class="panel-empty">${emptyMsg(key)}</div>`;
    panel.count = 0;
    panel.countEl.textContent = '0';
    if (key === 'input' || key === 'output') {
        groupedTerminalRows[key] = createGroupedRowState();
    }
}
function emptyMsg(k) {
    return { launch:'Waiting for terminal launch...', input:'Waiting for input...', output:'Waiting for output...',
             mcp:'Waiting for MCP calls...', logs:'Waiting for log entries...',
             http:'Waiting for requests...' }[k] || '';
}

// ─────────────────────────────────────────────────────────────────────────────
// Search — filters visibility of existing rows
// ─────────────────────────────────────────────────────────────────────────────
document.getElementById('global-search').addEventListener('input', function() {
    globalSearch = this.value.toLowerCase();
    for (const panel of Object.values(panels)) {
        panel.body.querySelectorAll('.event-row').forEach(row => {
            applySearchVisibility(row);
        });
    }
});

function createGroupedRowState() {
    return { row: null, textEl: null, text: '' };
}

function applySearchVisibility(row) {
    const text = (row.dataset.summary || '') + (row.dataset.detail || '');
    row.style.display = (!globalSearch || text.toLowerCase().includes(globalSearch)) ? '' : 'none';
}

function stripAnsi(text) {
    if (!text) return '';

    return text
        // OSC sequences: ESC ] ... BEL or ESC \\
        .replace(/\x1B\][^\x07]*(?:\x07|\x1B\\)/g, '')
        // CSI sequences: ESC [ ... command
        .replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '')
        // Remaining short ESC sequences
        .replace(/\x1B[@-_]/g, '');
}

function normalizeOutputChunk(raw) {
    if (!raw) return '';
    return stripAnsi(raw).replace(/\r(?!\n)/g, '');
}

function appendInputChunk(current, chunk) {
    if (!chunk) return current;

    let next = current;
    for (const ch of chunk) {
        if (ch === '\b' || ch === '\x7f') {
            next = next.slice(0, -1);
            continue;
        }
        if (ch === '\r' || ch === '\n') {
            continue;
        }
        next += ch;
    }

    return next;
}

function ensureGroupedTerminalRow(kind, typeName, panel, evt) {
    const state = groupedTerminalRows[kind];
    if (state.row) return state;

    const row = buildRow(
        { summary: '', detail: '', timestamp: evt.timestamp, durationMs: evt.durationMs },
        typeName
    );
    const textEl = row.querySelector('.ev-text');
    if (!textEl) return state;

    textEl.textContent = '';
    row.dataset.summary = '';
    row.dataset.detail = '';
    panel.body.appendChild(row);

    panel.count++;
    panel.countEl.textContent = panel.count;

    state.row = row;
    state.textEl = textEl;
    return state;
}

function finalizeGroupedTerminalRow(kind) {
    const panel = panels[kind];
    const state = groupedTerminalRows[kind];
    if (!panel || !state.row) {
        groupedTerminalRows[kind] = createGroupedRowState();
        return;
    }

    if (!state.text.trim()) {
        state.row.remove();
        panel.count = Math.max(0, panel.count - 1);
        panel.countEl.textContent = panel.count;
    }

    groupedTerminalRows[kind] = createGroupedRowState();
}

function dispatchGroupedTerminalEvent(kind, evt) {
    const panel = panels[kind];
    if (!panel) return;

    panel.body.querySelector('.panel-empty')?.remove();

    const typeName = kind === 'input' ? 'TerminalInput' : 'TerminalOutput';
    const raw = evt.detail || stripPrefix(evt.summary, typeName);
    if (!raw) return;

    const state = groupedTerminalRows[kind];
    const hasNewline = kind === 'input' ? /[\r\n]/.test(raw) : raw.includes('\n');

    if (kind === 'input') {
        state.text = appendInputChunk(state.text, raw);
    } else {
        state.text += normalizeOutputChunk(raw);
    }

    if (state.text.length > 0) {
        ensureGroupedTerminalRow(kind, typeName, panel, evt);
    }

    if (state.row && state.textEl) {
        state.textEl.textContent = state.text;
        state.row.dataset.summary = state.text;
        state.row.dataset.detail = state.text;
        applySearchVisibility(state.row);
    }

    if (panel.autoScroll) {
        panel.body.scrollTop = panel.body.scrollHeight;
    }

    if (hasNewline || state.text.length >= 4000) {
        finalizeGroupedTerminalRow(kind);
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Dispatch incoming trace event to the right panel
// — Details are ALWAYS shown inline, never collapsed
// ─────────────────────────────────────────────────────────────────────────────
function dispatchEvt(evt) {
    const typeName = mapType(evt.type);

    if (!isTypeEnabled(typeName)) return;

    if (typeName === 'TerminalOutput') {
        feedTerminal(evt);
        dispatchGroupedTerminalEvent('output', evt);
        return;
    }

    if (typeName === 'TerminalInput') {
        dispatchGroupedTerminalEvent('input', evt);
        return;
    }

    const panelKey = TYPE_PANEL[typeName];
    if (!panelKey) return;

    const panel = panels[panelKey];
    panel.body.querySelector('.panel-empty')?.remove();

    const row = buildRow(evt, typeName);
    applySearchVisibility(row);

    panel.body.appendChild(row);

    // Detail block: always visible inline — no click-to-expand
    // TerminalOutput detail is raw ANSI — rendered in xterm console, not here.
    if (evt.detail && typeName !== 'TerminalOutput') {
        const detail = document.createElement('div');
        detail.className = 'event-detail';
        detail.textContent = tryFmtJson(evt.detail);
        panel.body.appendChild(detail);
    }

    panel.count++;
    panel.countEl.textContent = panel.count;

    if (panel.autoScroll) panel.body.scrollTop = panel.body.scrollHeight;
}

function buildRow(evt, typeName) {
    const row = document.createElement('div');
    row.className = 'event-row';
    if (typeName === 'McpToolCall')   row.classList.add('ev-call');
    if (typeName === 'McpToolResult') row.classList.add('ev-result');
    if (typeName === 'LogEntry') {
        const s = evt.summary || '';
        if (s.startsWith('[ERR]') || s.startsWith('[FTL]')) row.classList.add('ev-err');
        else if (s.startsWith('[WRN]'))                      row.classList.add('ev-wrn');
        else if (s.startsWith('[DBG]') || s.startsWith('[VRB]')) row.classList.add('ev-dbg');
    }
    if (typeName === 'HttpRequest') {
        const m = (evt.summary || '').match(/→ (\d{3})/);
        if (m) {
            const code = parseInt(m[1]);
            if (code >= 500) row.classList.add('ev-err');
            else if (code >= 400) row.classList.add('ev-wrn');
        }
    }

    row.dataset.summary = evt.summary || '';
    row.dataset.detail  = evt.detail  || '';

    const time = new Date(evt.timestamp).toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });
    const dur  = evt.durationMs != null ? `${Math.round(evt.durationMs)}ms` : '';

    row.innerHTML = `
        <div class="ev-meta">
            <span class="ev-time">${time}</span>
            ${dur ? `<span class="ev-duration">${dur}</span>` : ''}
        </div>
        <div class="ev-text">${esc(stripPrefix(evt.summary, typeName))}</div>
    `;
    return row;
}

function stripPrefix(text, typeName) {
    if (!text) return '';
    const prefixes = ['Terminal launch: ','Input (LocalWebUi): ','Input (LocalCli): ','Input (Pty): ',
                      'Output: ','MCP call: ','MCP result: ','MCP error: '];
    for (const p of prefixes) if (text.startsWith(p)) return text.slice(p.length);
    return text;
}

function mapType(t) {
    if (typeof t === 'string') return t;
    return TYPE_NAMES[t] || 'LogEntry';
}

// ─────────────────────────────────────────────────────────────────────────────
// SSE — trace event stream
// ─────────────────────────────────────────────────────────────────────────────
function connectSSE() {
    setStatus('connecting');
    const es = new EventSource('/api/v1/trace/stream');
    es.addEventListener('trace', e => {
        try {
            const evt = JSON.parse(e.data);
            if (paused) pending.push(evt); else dispatchEvt(evt);
        } catch {}
    });
    es.onopen  = () => setStatus('connected');
    es.onerror = () => { setStatus('disconnected'); es.close(); setTimeout(connectSSE, 3000); };
}

function setStatus(state) {
    document.getElementById('status-dot').className   = `status-dot ${state}`;
    document.getElementById('status-label').textContent = { connected:'Connected', disconnected:'Disconnected', connecting:'Connecting...' }[state];
}

// ─────────────────────────────────────────────────────────────────────────────
// xterm.js — read-only console mirror (bottom-right panel)
// Fed from SSE TerminalOutput trace events — does NOT connect to the live
// terminal WebSocket so it never takes over the active session.
// ─────────────────────────────────────────────────────────────────────────────
const termStatusEl = document.getElementById('terminal-status');
const termWrap     = document.getElementById('terminal-wrap');

const term = new Terminal({
    theme: {
        background:  '#0d0d1a',
        foreground:  '#d4d4d4',
        cursor:      '#569cd6',
        black:       '#1e1e1e',
        brightBlack: '#555',
        white:       '#d4d4d4',
        brightWhite: '#ffffff',
    },
    fontSize: 12,
    fontFamily: "'Cascadia Code', 'Fira Code', 'Consolas', monospace",
    cursorBlink: false,
    scrollback: 2000,
    disableStdin: true,
    convertEol: true,
});

const fitAddon = new FitAddon.FitAddon();
term.loadAddon(fitAddon);
term.open(termWrap);
fitAddon.fit();

// Build the right-side stack (LAUNCH / INPUT / OUTPUT / CONSOLE)
renderStackLayout();

// Resize observer to refit xterm when panel resizes
new ResizeObserver(() => { try { fitAddon.fit(); } catch {} }).observe(termWrap);

// Called by dispatchEvt for every TerminalOutput event
function feedTerminal(evt) {
    // Use raw ANSI detail if available, otherwise fall back to plain summary text
    const raw = evt.detail || stripPrefix(evt.summary, 'TerminalOutput');
    if (raw) {
        term.write(raw);
        term.scrollToBottom();
    }
    termStatusEl.textContent = 'receiving output';
}

document.getElementById('term-reconnect-btn').addEventListener('click', () => {
    term.clear();
    termStatusEl.textContent = 'cleared — waiting for output...';
});

// ─────────────────────────────────────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────────────────────────────────────
function esc(s) {
    return (s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}
function tryFmtJson(s) {
    try { return JSON.stringify(JSON.parse(s), null, 2); } catch { return s; }
}

// ─────────────────────────────────────────────────────────────────────────────
// Panel visibility — persisted to localStorage
// ─────────────────────────────────────────────────────────────────────────────
const PANEL_VIS_KEY = 'trace-panel-vis-v1';
// Panels controllable via settings; 'console' always stays in stack logic
const ALL_PANEL_IDS = ['mcp', 'http', 'logs', 'proc', 'launch', 'input', 'output', 'console'];
const panelVisible = loadPanelVisibility();

function loadPanelVisibility() {
    try {
        const saved = JSON.parse(localStorage.getItem(PANEL_VIS_KEY) || '{}');
        const result = {};
        for (const id of ALL_PANEL_IDS) result[id] = saved[id] !== false;
        return result;
    } catch { return Object.fromEntries(ALL_PANEL_IDS.map(id => [id, true])); }
}

function savePanelVisibility() {
    try { localStorage.setItem(PANEL_VIS_KEY, JSON.stringify(panelVisible)); } catch {}
}

function applyPanelVisibility(id) {
    const visible = panelVisible[id];
    // Stack panels (right column) use the existing minimize system
    if (stackPanelKeys.includes(id)) {
        setStackPaneMinimized(id, !visible);
        return;
    }
    // Left-column panels
    const el = document.getElementById(`panel-${id}`);
    if (el) el.classList.toggle('panel-hidden', !visible);
}

function applyAllPanelVisibility() {
    for (const id of ALL_PANEL_IDS) applyPanelVisibility(id);
}

// ─────────────────────────────────────────────────────────────────────────────
// Process monitor — polls /api/v1/trace/processes every 3 s
// ─────────────────────────────────────────────────────────────────────────────
const procBody  = document.getElementById('body-proc');
const procCount = document.getElementById('count-proc');
const procAge   = document.getElementById('proc-age');
let procLastFetch = null;
let procAgeTimer  = null;

function startProcAgeTimer() {
    if (procAgeTimer) return;
    procAgeTimer = setInterval(() => {
        if (!procLastFetch) return;
        const secs = Math.round((Date.now() - procLastFetch) / 1000);
        if (procAge) procAge.textContent = `${secs}s ago`;
    }, 1000);
}

async function fetchProcesses() {
    try {
        const res = await fetch('/api/v1/trace/processes');
        if (!res.ok) { renderProcError(`HTTP ${res.status}`); return; }
        const data = await res.json();
        procLastFetch = Date.now();
        renderProcTable(data.processes || []);
    } catch (e) {
        renderProcError(e.message || 'fetch failed');
    }
}

function fmtUptime(isoStart) {
    if (!isoStart) return '?';
    const secs = Math.floor((Date.now() - new Date(isoStart).getTime()) / 1000);
    if (secs < 60)   return `${secs}s`;
    if (secs < 3600) return `${Math.floor(secs/60)}m ${secs%60}s`;
    const h = Math.floor(secs/3600), m = Math.floor((secs%3600)/60);
    return `${h}h ${m}m`;
}

function renderProcTable(procs) {
    if (procCount) procCount.textContent = procs.length;
    if (!procBody) return;

    if (procs.length === 0) {
        procBody.innerHTML = '<div class="panel-empty">No vb processes running</div>';
        return;
    }

    const rows = procs.map(p => `<tr>
        <td class="col-pid">${p.pid}</td>
        <td class="col-uptime">${fmtUptime(p.startTime)}</td>
        ${p.title ? `<td class="col-title">${esc(p.title)}</td>` : '<td class="col-title" style="color:#333">—</td>'}
    </tr>`).join('');

    procBody.innerHTML = `<table class="proc-table">
        <thead><tr><th>PID</th><th>Uptime</th><th>Title</th></tr></thead>
        <tbody>${rows}</tbody>
    </table>`;
}

function renderProcError(msg) {
    if (procBody) procBody.innerHTML = `<div class="panel-empty" style="color:#f48771">${esc(msg)}</div>`;
}

// ─────────────────────────────────────────────────────────────────────────────
// Settings popover — filter toggles
// ─────────────────────────────────────────────────────────────────────────────
(function initSettingsPopover() {
    const settingsBtn = document.getElementById('settings-btn');
    const popover     = document.getElementById('settings-popover');

    // Apply saved state to checkboxes
    for (const t of ALL_FILTER_TYPES) {
        const cb = document.getElementById(`filter-${t}`);
        if (cb) cb.checked = typeFilters[t];
    }

    // Toggle popover
    settingsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        popover.classList.toggle('hidden');
    });

    // Close on outside click
    document.addEventListener('click', (e) => {
        if (!popover.contains(e.target) && e.target !== settingsBtn) {
            popover.classList.add('hidden');
        }
    });

    // Checkbox changes
    for (const t of ALL_FILTER_TYPES) {
        const cb = document.getElementById(`filter-${t}`);
        if (!cb) continue;
        cb.addEventListener('change', () => {
            typeFilters[t] = cb.checked;
            saveFilters();
        });
    }

    // All / None buttons
    document.getElementById('filter-all-btn').addEventListener('click', () => {
        for (const t of ALL_FILTER_TYPES) {
            typeFilters[t] = true;
            const cb = document.getElementById(`filter-${t}`);
            if (cb) cb.checked = true;
        }
        saveFilters();
    });
    document.getElementById('filter-none-btn').addEventListener('click', () => {
        for (const t of ALL_FILTER_TYPES) {
            typeFilters[t] = false;
            const cb = document.getElementById(`filter-${t}`);
            if (cb) cb.checked = false;
        }
        saveFilters();
    });

    // Panel visibility checkboxes
    for (const id of ALL_PANEL_IDS) {
        const cb = document.getElementById(`panel-show-${id}`);
        if (!cb) continue;
        cb.checked = panelVisible[id];
        cb.addEventListener('change', () => {
            panelVisible[id] = cb.checked;
            savePanelVisibility();
            applyPanelVisibility(id);
        });
    }
})();

// ─────────────────────────────────────────────────────────────────────────────
// Connect bar — navigate to another instance via bootstrap URL
// ─────────────────────────────────────────────────────────────────────────────
(function initConnectBar() {
    const toggleBtn  = document.getElementById('connect-toggle-btn');
    const bar        = document.getElementById('connect-bar');
    const portInput  = document.getElementById('connect-port');
    const codeInput  = document.getElementById('connect-code');
    const goBtn      = document.getElementById('connect-go-btn');
    const hint       = document.getElementById('connect-hint');

    toggleBtn.addEventListener('click', () => {
        bar.classList.toggle('hidden');
        if (!bar.classList.contains('hidden')) portInput.focus();
    });

    // If user pastes a full URL, auto-parse port + code from it
    codeInput.addEventListener('input', () => {
        const val = codeInput.value.trim();
        try {
            const url = new URL(val);
            const code = url.searchParams.get('code');
            const port = url.port || (url.protocol === 'https:' ? '443' : '80');
            if (code && port) {
                portInput.value = port;
                codeInput.value = code;
                hint.textContent = `Parsed port ${port} from URL.`;
                hint.className = 'connect-hint';
            }
        } catch { /* not a URL, that's fine */ }
    });

    goBtn.addEventListener('click', doConnect);
    codeInput.addEventListener('keydown', e => { if (e.key === 'Enter') doConnect(); });
    portInput.addEventListener('keydown', e => { if (e.key === 'Enter') codeInput.focus(); });

    function doConnect() {
        const port = parseInt(portInput.value, 10);
        const code = codeInput.value.trim();

        if (!port || port < 1 || port > 65535) {
            showError('Enter a valid port number.');
            return;
        }
        if (!code) {
            showError('Paste the bootstrap code or URL.');
            return;
        }

        // Navigate to the target instance's bootstrap endpoint.
        // It will set the cookie for that origin and redirect back to /trace.html.
        const url = `http://localhost:${port}/auth/bootstrap?code=${encodeURIComponent(code)}&redirect=/trace.html`;
        window.location.href = url;
    }

    function showError(msg) {
        hint.textContent = msg;
        hint.className = 'connect-error';
    }
})();

// ─────────────────────────────────────────────────────────────────────────────
// Boot
// ─────────────────────────────────────────────────────────────────────────────
applyAllPanelVisibility();
fetchProcesses();
setInterval(fetchProcesses, 3000);
startProcAgeTimer();
connectSSE();
</script>
</body>
</html>
